# Проанализировать скорость и сложность одного любого алгоритма, разработанных в рамках домашнего задания первых трех
# уроков.
# В диапазоне натуральных чисел от 2 до 99 определить,
# сколько из них кратны каждому из чисел в диапазоне от 2 до 9.

import cProfile


MIN_DIV = 2
MAX_DIV = 9


def div_count(max_number):
    div_dict = dict()

    for div in range(MIN_DIV, MAX_DIV + 1):
        div_dict[div] = max_number // div

    return div_dict

# Алгоритм работает приблизительно за O(1). Т.к. при увеличении количества элементов в 10 раз на каждый запуск
#  время выполнения увеличивалось незначительно. При увеличении количества входных элементов в 1000 раз время
#  увеличилось всего на 7,5%

def div_count_dict(max_number):
    div_dict = dict()

    for div in range(MIN_DIV, MAX_DIV + 1):
        div_dict[div] = 0

        for num in range(2, max_number + 1):

            if num % div == 0:
                div_dict[div] += 1

    return div_dict

# Алгоритм работает приблизительно за O(n). Т.к. при увеличении количества элементов в 10 раз на каждый запуск
#  время выполнения увеличивается приблизительно в 10 раз.
# И даже на самом маленьком размере входных данных алгоритм работает значительно медленнее, чем div_count()

def div_count_xxxx(max_number):
    div_dict = {2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 8: 0, 9: 0}

    for num in range(2, max_number + 1):

        if num % 2 == 0:
            div_dict[2] += 1

        if num % 3 == 0:
            div_dict[3] += 1

        if num % 4 == 0:
            div_dict[4] += 1

        if num % 5 == 0:
            div_dict[5] += 1

        if num % 6 == 0:
            div_dict[6] += 1

        if num % 7 == 0:
            div_dict[7] += 1

        if num % 8 == 0:
            div_dict[8] += 1

        if num % 9 == 0:
            div_dict[9] += 1

    return div_dict

# Алгоритм работает приблизительно за O(n). Т.к. при увеличении количества элементов в 10 раз на каждый запуск
#  время выполнения увеличивается приблизительно в 10 раз.
# И даже на самом маленьком размере входных данных алгоритм работает значительно медленнее, чем div_count(),
# при этом этот алгоритм чуть быстрее, чем div_count_dict()

# ВЫВОД:
# Алгоритм, использованный в функции div_count(), является самым оптимальным и быстрым.
# Так как он выполняется практически за константное время, несильно завися от размера входных данных.
